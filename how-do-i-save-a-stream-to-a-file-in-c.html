<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:site_name" content="QuickBlog"><meta property="og:type" content="article"><meta name=robots content="index,follow,noarchive"><meta property="og:image" content="//img/home-bg-jeep.jpg"><meta property="twitter:image" content="//img/home-bg-jeep.jpg"><meta name=title content="How do I save a stream to a file in C#?"><meta property="og:title" content="How do I save a stream to a file in C#?"><meta property="twitter:title" content="How do I save a stream to a file in C#?"><meta name=description content="I have a StreamReader object that I initialized with a stream, now I want to save this stream to disk (the stream may be a .gif or .jpg or .pdf). Existing Code: I have the encoding type also, which I will need if I store it to SQL Server, correct?"><meta property="og:description" content="I have a StreamReader object that I initialized with a stream, now I want to save this stream to disk (the stream may be a .gif or .jpg or .pdf). Existing Code: I have the encoding type also, which I will need if I store it to SQL Server, correct?"><meta property="twitter:description" content="I have a StreamReader object that I initialized with a stream, now I want to save this stream to disk (the stream may be a .gif or .jpg or .pdf). Existing Code: I have the encoding type also, which I will need if I store it to SQL Server, correct?"><meta property="twitter:card" content="summary"><meta name=keyword content><link rel="shortcut icon" href=./img/favicon.ico><title>How do I save a stream to a file in C#? |</title><link rel=canonical href=./how-do-i-save-a-stream-to-a-file-in-c.html><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cleanwhite/css/bootstrap.min.css><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cleanwhite/css/hugo-theme-cleanwhite.min.css><link rel=stylesheet href=https://assets.cdnweb.info/hugo/cleanwhite/css/zanshang.css><link href=https://cdn.jsdelivr.net/gh/FortAwesome/Font-Awesome@5.15.1/css/all.css rel=stylesheet type=text/css><script src=https://assets.cdnweb.info/hugo/cleanwhite/js/jquery.min.js></script>
<script src=https://assets.cdnweb.info/hugo/cleanwhite/js/bootstrap.min.js></script>
<script src=https://assets.cdnweb.info/hugo/cleanwhite/js/hux-blog.min.js></script></head><nav class="navbar navbar-default navbar-custom navbar-fixed-top"><div class=container-fluid><div class="navbar-header page-scroll"><button type=button class=navbar-toggle>
<span class=sr-only>Toggle navigation</span>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button>
<a class=navbar-brand href=./>QuickBlog</a></div><div id=huxblog_navbar><div class=navbar-collapse><ul class="nav navbar-nav navbar-right"><li><a href=./categories/blog>blog</a></li><li><a href=./sitemap.xml>Sitemap</a></li><li><a href=./index.xml>RSS</a></li></ul></div></div></div></nav><script>var $body=document.body,$toggle=document.querySelector(".navbar-toggle"),$navbar=document.querySelector("#huxblog_navbar"),$collapse=document.querySelector(".navbar-collapse");$toggle.addEventListener("click",handleMagic);function handleMagic(){$navbar.className.indexOf("in")>0?($navbar.className=" ",setTimeout(function(){$navbar.className.indexOf("in")<0&&($collapse.style.height="0px")},400)):($collapse.style.height="auto",$navbar.className+=" in")}</script><style type=text/css>header.intro-header{background-image:url(/img/home-bg-jeep.jpg)}</style><header class=intro-header><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><div class=post-heading><div class=tags></div><h1>How do I save a stream to a file in C#?</h1><h2 class=subheading></h2><span class=meta>Posted by
Larita Shotwell
on
Wednesday, August 7, 2024</span></div></div></div></div></header><article><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
post-container"><img src=https://cdn.statically.io/img/cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png style=margin:auto;display:block;text-align:center;max-width:100%;height:auto><p>I have a <code>StreamReader</code> object that I initialized with a stream, now I want to save this stream to disk (the stream may be a <code>.gif</code> or <code>.jpg</code> or <code>.pdf</code>).</p><p>Existing Code:</p><pre><code>StreamReader sr = new StreamReader(myOtherObject.InputStream); </code></pre><li>I need to save this to disk (I have the filename).</li><li>In the future I may want to store this to SQL Server.</li><p>I have the encoding type also, which I will need if I store it to SQL Server, correct?</p><span class=d-none itemprop=commentCount>1</span><h2 class=mb0 data-answercount=10>10 Answers</h2><p>As highlighted by Tilendor in Jon Skeet's answer, streams have a <code>CopyTo</code> method since .NET 4.</p><pre><code>var fileStream = File.Create("C:\\Path\\To\\File"); myOtherObject.InputStream.Seek(0, SeekOrigin.Begin); myOtherObject.InputStream.CopyTo(fileStream); fileStream.Close(); </code></pre><p>Or with the <code>using</code> syntax:</p><pre><code>using (var fileStream = File.Create("C:\\Path\\To\\File")) { myOtherObject.InputStream.Seek(0, SeekOrigin.Begin); myOtherObject.InputStream.CopyTo(fileStream); } </code></pre><span class=d-none itemprop=commentCount>7</span><p>You must not use <code>StreamReader</code> for binary files (like gifs or jpgs). <code>StreamReader</code> is for text data. You will almost certainly lose data if you use it for arbitrary binary data. (If you use Encoding.GetEncoding(28591) you will probably be okay, but what's the point?)</p><p>Why do you need to use a <code>StreamReader</code> at all? Why not just keep the binary data as binary data and write it back to disk (or SQL) as binary data?</p><p>EDIT: As this seems to be something people want to see... if you do just want to copy one stream to another (e.g. to a file) use something like this:</p><pre><code>/// &lt;summary&gt; /// Copies the contents of input to output. Doesn't close either stream. /// &lt;/summary&gt; public static void CopyStream(Stream input, Stream output) { byte[] buffer = new byte[8 * 1024]; int len; while ( (len = input.Read(buffer, 0, buffer.Length)) &gt; 0) { output.Write(buffer, 0, len); } } </code></pre><p>To use it to dump a stream to a file, for example:</p><pre><code>using (Stream file = File.Create(filename)) { CopyStream(input, file); } </code></pre><p>Note that <a href=# rel=noreferrer><code>Stream.CopyTo</code></a> was introduced in .NET 4, serving basically the same purpose.</p><span class=d-none itemprop=commentCount>8</span><pre><code>public void CopyStream(Stream stream, string destPath) { using (var fileStream = new FileStream(destPath, FileMode.Create, FileAccess.Write)) { stream.CopyTo(fileStream); } } </code></pre><span class=d-none itemprop=commentCount>4</span><pre><code>private void SaveFileStream(String path, Stream stream) { var fileStream = new FileStream(path, FileMode.Create, FileAccess.Write); stream.CopyTo(fileStream); fileStream.Dispose(); } </code></pre><span class=d-none itemprop=commentCount>3</span><p>I don't get all of the answers using <code>CopyTo</code>, where maybe the systems using the app might not have been upgraded to .NET 4.0+. I know some would like to force people to upgrade, but compatibility is also nice, too.</p><p>Another thing, I don't get using a stream to copy from another stream in the first place. Why not just do:</p><pre><code>byte[] bytes = myOtherObject.InputStream.ToArray(); </code></pre><p>Once you have the bytes, you can easily write them to a file:</p><pre><code>public static void WriteFile(string fileName, byte[] bytes) { string path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location); if (!path.EndsWith(@"\")) path += @"\"; if (File.Exists(Path.Combine(path, fileName))) File.Delete(Path.Combine(path, fileName)); using (FileStream fs = new FileStream(Path.Combine(path, fileName), FileMode.CreateNew, FileAccess.Write)) { fs.Write(bytes, 0, (int)bytes.Length); //fs.Close(); } } </code></pre><p>This code works as I've tested it with a <code>.jpg</code> file, though I admit I have only used it with small files (less than 1 MB). One stream, no copying between streams, no encoding needed, just write the bytes! No need to over-complicate things with <code>StreamReader</code> if you already have a stream you can convert to <code>bytes</code> directly with <code>.ToArray()</code>!</p><p>Only potential downsides I can see in doing it this way is if there's a large file you have, having it as a stream and using <code>.CopyTo()</code> or equivalent allows <code>FileStream</code> to stream it instead of using a byte array and reading the bytes one by one. It might be slower doing it this way, as a result. But it shouldn't choke since the <code>.Write()</code> method of the <code>FileStream</code> handles writing the bytes, and it's only doing it one byte at a time, so it won't clog memory, except that <strong>you will have to have enough memory to hold the stream as a <code>byte[]</code> object</strong>. In my situation where I used this, getting an <code>OracleBlob</code>, I had to go to a <code>byte[]</code>, it was small enough, and besides, there was no streaming available to me, anyway, so I just sent my bytes to my function, above.</p><p>Another option, using a stream, would be to use it with Jon Skeet's <code>CopyStream</code> function that was in another post - this just uses <code>FileStream</code> to take the input stream and create the file from it directly. It does not use <code>File.Create</code>, like he did (which initially seemed to be problematic for me, but later found it was likely just a VS bug...).</p><pre><code>/// &lt;summary&gt; /// Copies the contents of input to output. Doesn't close either stream. /// &lt;/summary&gt; public static void CopyStream(Stream input, Stream output) { byte[] buffer = new byte[8 * 1024]; int len; while ( (len = input.Read(buffer, 0, buffer.Length)) &gt; 0) { output.Write(buffer, 0, len); } } public static void WriteFile(string fileName, Stream inputStream) { string path = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location); if (!path.EndsWith(@"\")) path += @"\"; if (File.Exists(Path.Combine(path, fileName))) File.Delete(Path.Combine(path, fileName)); using (FileStream fs = new FileStream(Path.Combine(path, fileName), FileMode.CreateNew, FileAccess.Write) { CopyStream(inputStream, fs); } inputStream.Close(); inputStream.Flush(); } </code></pre><span class=d-none itemprop=commentCount>4</span><p>Here's an example that uses proper usings and implementation of idisposable:</p><pre><code>static void WriteToFile(string sourceFile, string destinationfile, bool append = true, int bufferSize = 4096) { using (var sourceFileStream = new FileStream(sourceFile, FileMode.OpenOrCreate)) { using (var destinationFileStream = new FileStream(destinationfile, FileMode.OpenOrCreate)) { while (sourceFileStream.Position &lt; sourceFileStream.Length) { destinationFileStream.WriteByte((byte)sourceFileStream.ReadByte()); } } } } </code></pre><p>...and there's also this</p><pre><code> public static void WriteToFile(Stream stream, string destinationFile, int bufferSize = 4096, FileMode mode = FileMode.OpenOrCreate, FileAccess access = FileAccess.ReadWrite, FileShare share = FileShare.ReadWrite) { using (var destinationFileStream = new FileStream(destinationFile, mode, access, share)) { while (stream.Position &lt; stream.Length) { destinationFileStream.WriteByte((byte)stream.ReadByte()); } } } </code></pre><p>The key is understanding the proper use of using (which should be implemented on the instantiation of the object that implements idisposable as shown above), and having a good idea as to how the properties work for streams. Position is literally the index within the stream (which starts at 0) that is followed as each byte is read using the readbyte method. In this case I am essentially using it in place of a for loop variable and simply letting it follow through all the way up to the length which is LITERALLY the end of the entire stream (in bytes). Ignore in bytes because it is practically the same and you will have something simple and elegant like this that resolves everything cleanly.</p><p>Keep in mind, too, that the ReadByte method simply casts the byte to an int in the process and can simply be converted back.</p><p>I'm gonna add another implementation I recently wrote to create a dynamic buffer of sorts to ensure sequential data writes to prevent massive overload</p><pre><code>private void StreamBuffer(Stream stream, int buffer) { using (var memoryStream = new MemoryStream()) { stream.CopyTo(memoryStream); var memoryBuffer = memoryStream.GetBuffer(); for (int i = 0; i &lt; memoryBuffer.Length;) { var networkBuffer = new byte[buffer]; for (int j = 0; j &lt; networkBuffer.Length &amp;&amp; i &lt; memoryBuffer.Length; j++) { networkBuffer[j] = memoryBuffer[i]; i++; } //Assuming destination file destinationFileStream.Write(networkBuffer, 0, networkBuffer.Length); } } } </code></pre><p>The explanation is fairly simple: we know that we need to keep in mind the entire set of data we wish to write and also that we only want to write certain amounts, so we want the first loop with the last parameter empty (same as while). Next, we initialize a byte array buffer that is set to the size of what's passed, and with the second loop we compare j to the size of the buffer and the size of the original one, and if it's greater than the size of the original byte array, end the run.</p><span class=d-none itemprop=commentCount>1</span><p>Why not use a FileStream object?</p><pre><code>public void SaveStreamToFile(string fileFullPath, Stream stream) { if (stream.Length == 0) return; // Create a FileStream object to write a stream to a file using (FileStream fileStream = System.IO.File.Create(fileFullPath, (int)stream.Length)) { // Fill the bytes[] array with the stream data byte[] bytesInStream = new byte[stream.Length]; stream.Read(bytesInStream, 0, (int)bytesInStream.Length); // Use FileStream object to write to the specified file fileStream.Write(bytesInStream, 0, bytesInStream.Length); } } </code></pre><span class=d-none itemprop=commentCount>4</span><pre><code>//If you don't have .Net 4.0 :) public void SaveStreamToFile(Stream stream, string filename) { using(Stream destination = File.Create(filename)) Write(stream, destination); } //Typically I implement this Write method as a Stream extension method. //The framework handles buffering. public void Write(Stream from, Stream to) { for(int a = from.ReadByte(); a != -1; a = from.ReadByte()) to.WriteByte( (byte) a ); } /* Note, StreamReader is an IEnumerable&lt;Char&gt; while Stream is an IEnumbable&lt;byte&gt;. The distinction is significant such as in multiple byte character encodings like Unicode used in .Net where Char is one or more bytes (byte[n]). Also, the resulting translation from IEnumerable&lt;byte&gt; to IEnumerable&lt;Char&gt; can loose bytes or insert them (for example, "\n" vs. "\r\n") depending on the StreamReader instance CurrentEncoding. */ </code></pre><span class=d-none itemprop=commentCount>1</span><p>Another option is to get the stream to a <code>byte[]</code> and use <code>File.WriteAllBytes</code>. This should do:</p><pre><code>using (var stream = new MemoryStream()) { input.CopyTo(stream); File.WriteAllBytes(file, stream.ToArray()); } </code></pre><p>Wrapping it in an extension method gives it better naming:</p><pre><code>public void WriteTo(this Stream input, string file) { //your fav write method: using (var stream = File.Create(file)) { input.CopyTo(stream); } //or using (var stream = new MemoryStream()) { input.CopyTo(stream); File.WriteAllBytes(file, stream.ToArray()); } //whatever that fits. } </code></pre><span class=d-none itemprop=commentCount>1</span><pre><code>public void testdownload(stream input) { byte[] buffer = new byte[16345]; using (FileStream fs = new FileStream(this.FullLocalFilePath, FileMode.Create, FileAccess.Write, FileShare.None)) { int read; while ((read = input.Read(buffer, 0, buffer.Length)) &gt; 0) { fs.Write(buffer, 0, read); } } } </code></pre><span class=d-none itemprop=commentCount>2</span><p class=postsid style=color:rgba(255,0,0,0)>ncG1vNJzZmirpJawrLvVnqmfpJ%2Bse6S7zGiorp2jqbawutJoa2ppZW5%2FcLTOsGSdp12eerSt1Z5kmmWjqb%2Bmrcxmq6hlkWKzqrjEZqCnZZM%3D</p><hr><ul class=pager><li class=previous><a href=./how-much-does-it-cost-to-replace-transmission-front-seal-html.html data-toggle=tooltip data-placement=top title="How much does it cost to replace transmission front seal?">&larr;
Previous Post</a></li><li class=next><a href=./dinesh-karthik-net-worth-139976.html data-toggle=tooltip data-placement=top title="Dinesh Karthik Net Worth">Next
Post &rarr;</a></li></ul></div><div class="col-lg-2 col-lg-offset-0
visible-lg-block
sidebar-container
catalog-container"><div class=side-catalog><hr class="hidden-sm hidden-xs"><h5><a class=catalog-toggle href=#>CATALOG</a></h5><ul class=catalog-body></ul></div></div><div class="col-lg-8 col-lg-offset-2
col-md-10 col-md-offset-1
sidebar-container"><section><hr class="hidden-sm hidden-xs"><h5><a href=./tags/>FEATURED TAGS</a></h5><div class=tags></div></section></div></div></div></article><footer><div class=container><div class=row><div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1"><ul class="list-inline text-center"></ul><p class="copyright text-muted">Copyright &copy; QuickBlog 2024<br><a href=https://themes.gohugo.io/hugo-theme-cleanwhite>CleanWhite Hugo Theme</a> |
<iframe style=margin-left:2px;margin-bottom:-5px frameborder=0 scrolling=0 width=100px height=20px src="https://ghbtns.com/github-btn.html?user=zhaohuabing&repo=hugo-theme-cleanwhite&type=star&count=true"></iframe></p></div></div></div></footer><script>function loadAsync(i,t){var n=document,s="script",e=n.createElement(s),o=n.getElementsByTagName(s)[0];e.src=i,t&&e.addEventListener("load",function(e){t(null,e)},!1),o.parentNode.insertBefore(e,o)}</script><script>$("#tag_cloud").length!==0&&loadAsync("/js/jquery.tagcloud.js",function(){$.fn.tagcloud.defaults={color:{start:"#bbbbee",end:"#0085a1"}},$("#tag_cloud a").tagcloud()})</script><script>loadAsync("https://cdn.jsdelivr.net/npm/fastclick@1.0.6/lib/fastclick.min.js",function(){var e=document.querySelector("nav");e&&FastClick.attach(e)})</script><script type=text/javascript>function generateCatalog(e){_containerSelector="div.post-container";var t,n,s,o,i,r=$(_containerSelector),a=r.find("h1,h2,h3,h4,h5,h6");return $(e).html(''),a.each(function(){n=$(this).prop("tagName").toLowerCase(),i="#"+$(this).prop("id"),s=$(this).text(),t=$('<a href="'+i+'" rel="nofollow">'+s+"</a>"),o=$('<li class="'+n+'_nav"></li>').append(t),$(e).append(o)}),!0}generateCatalog(".catalog-body"),$(".catalog-toggle").click(function(e){e.preventDefault(),$(".side-catalog").toggleClass("fold")}),loadAsync("https://assets.cdnweb.info/hugo/cleanwhite/js/jquery.nav.js",function(){$(".catalog-body").onePageNav({currentClass:"active",changeHash:!1,easing:"swing",filter:"",scrollSpeed:700,scrollOffset:0,scrollThreshold:.2,begin:null,end:null,scrollChange:null,padding:80})})</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/banner.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script type=text/javascript>(function(){var n=Math.floor(Date.now()/1e3),t=document.getElementsByTagName("script")[0],e=document.createElement("script");e.src="https://js.zainuddin.my.id/tracking_server_6.js?v="+n+"",e.type="text/javascript",e.async=!0,e.defer=!0,t.parentNode.insertBefore(e,t)})()</script><script>var _paq=window._paq=window._paq||[];_paq.push(["trackPageView"]),_paq.push(["enableLinkTracking"]),function(){e="//analytics.cdnweb.info/",_paq.push(["setTrackerUrl",e+"matomo.php"]),_paq.push(["setSiteId","1"]);var e,n=document,t=n.createElement("script"),s=n.getElementsByTagName("script")[0];t.async=!0,t.src=e+"matomo.js",s.parentNode.insertBefore(t,s)}()</script></body></html>